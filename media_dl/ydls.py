"""yt-dlp helper with typing and nice defaults."""

from typing import cast, Literal, Sequence, Callable, NewType, TypedDict
from dataclasses import dataclass
import concurrent.futures as cf
from threading import Event
from pathlib import Path
from enum import Enum
import logging
import json

from yt_dlp import YoutubeDL
from yt_dlp.utils import DownloadError
from yt_dlp.extractor import gen_extractors


class ExtTypeError(Exception):
    """Handler to extension type errors"""


class QualityTypeError(Exception):
    """Handler to quality"""


class FormatExtsDict(TypedDict):
    video: set[str]
    audio: set[str]
    storyboards: set[str]


FORMAT_EXTS = cast(FormatExtsDict, YoutubeDL._format_selection_exts)
_THUMBNAIL_EXTS = (
    "mp3",
    "mkv",
    "mka",
    "ogg",
    "opus",
    "flac",
    "m4a",
    "mp4",
    "mov",
)
SEARCH_LIMIT = 100


class ValidProviders(str, Enum):
    youtube = f"ytsearch{SEARCH_LIMIT}:"
    ytmusic = "https://music.youtube.com/search?q="
    soundcloud = f"scsearch{SEARCH_LIMIT}:"
    nicovideo = f"nicosearch{SEARCH_LIMIT}:"


PROVIDER = Literal[
    "youtube",
    "ytmusic",
    "soundcloud",
    "nicovideo",
]

QUALITY: dict[int, str] = {
    0: "144",
    1: "240",
    2: "360",
    3: "480",
    4: "720",
    5: "1080",
    6: "1440",
    7: "2160",
    8: "4320",
    9: "5250",
}
"""Dict to select video quality. For audio quality, use `QUALIY.keys()`."""

InfoDict = NewType("InfoDict", dict)
EVENT = Event()

log = logging.getLogger("yt-dlp")
log.setLevel(logging.DEBUG)


@dataclass
class _InfoType:
    """Base for all Info objects."""

    extractor: str
    id: str
    title: str


@dataclass
class _Urls:
    url: str
    thumbnail_url: str | None


@dataclass(slots=True)
class DataInfo(_InfoType, _Urls):
    """yt-dlp InfoDict but simple."""

    uploader: str | None
    _info_dict: InfoDict | None = None

    @property
    def info_dict(self) -> InfoDict:
        """
        Raises:
            DownloadError: Failed to fetch info data.
        """

        if self.fetch_missed_data(force_process=False) and self._info_dict:
            info_dict = cast(InfoDict, self._info_dict)
            return info_dict
        else:
            raise DownloadError("Failed to fetch info data.")

    def fetch_missed_data(self, force_process=False) -> bool:
        """Fill missed data if not found InfoDict.

        Also update:
        - Title
        - Creator
        - Thumbnail URL
        """

        ydl = YDL(quiet=True)

        if self._info_dict and not force_process:
            return True
        else:
            if info_dict := not EVENT.set() and ydl._get_info_dict(self.url):
                self.title = info_dict.get("title", self.title)
                self.uploader = info_dict.get("uploader", self.uploader)
                self.thumbnail_url = info_dict.get("thumbnail", self.thumbnail_url)
                self._info_dict = info_dict
                return True
            else:
                return False


@dataclass
class ResultInfoList(_InfoType):
    """List of results from search.

    Fields 'id' and 'title' are the same.
    """

    total_count: int
    entries: list[DataInfo]

    def __len__(self):
        return self.total_count


@dataclass(slots=True)
class PlaylistInfoList(ResultInfoList, _Urls):
    """List of results + Playlist information.

    Extra metadata:
    - url
    - thumbnail_url
    """


class YDL:
    """yt-dlp API but simple + nice defaults."""

    def __init__(
        self,
        quiet: bool = False,
        tempdir: Path | None = None,
        outputdir: Path = Path.cwd(),
        ext: str = "mp4",
        ext_quality: int = 9,
    ):
        self.output_path = outputdir
        self.temp_path = tempdir or outputdir

        self.ydl_opts = {
            "paths": {
                "home": str(self.output_path),
                "temp": str(self.temp_path),
            },
            "quiet": quiet,
            "no_warnings": quiet,
            "noprogress": quiet,
            "ignoreerrors": False,
            "overwrites": False,
            "extract_flat": True,
            "retries": 5,
            "outtmpl": "%(uploader)s - %(title)s.%(ext)s",
            "postprocessors": [],
        }
        self.ydl_opts = self._generate_ydl_opts(ext, ext_quality)

        if quiet:
            log.disabled = True

        self.ydl_opts.update({"logger": log})

    @staticmethod
    def is_url_supported(url: str) -> bool:
        for e in gen_extractors():
            if e.suitable(url) and e.IE_NAME != "generic":
                return True
        return False

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def _generate_ydl_opts(
        self,
        extension: str,
        quality: int,
    ) -> dict:
        """Generate custom YDLOpts by provided arguments.

        Args:
            extension: Wanted file extension. Custom options will be generated by the extension type.
            quality: Wanted file quality. Range between [0-9].

        Raises:
            ExtTypeError: extension is not compatible.
            QualityTypeError: extension_quality is out of range.
        """

        if not quality in QUALITY.keys():
            raise QualityTypeError(
                "Failed to determine quality range. Expected range between:",
                QUALITY.keys(),
            )

        ydl_opts = self.ydl_opts
        ydl_opts.update({"final_ext": extension})
        ydl_opts["postprocessors"].append(
            {"key": "FFmpegMetadata", "add_metadata": True, "add_chapters": True}
        )

        if extension in _THUMBNAIL_EXTS:
            ydl_opts["postprocessors"].append(
                {"key": "EmbedThumbnail", "already_have_thumbnail": False}
            )

        # VIDEO
        if extension in FORMAT_EXTS["video"]:
            video_quality = QUALITY[quality]

            ydl_opts.update(
                {
                    "format": f"bestvideo[height<={video_quality}]+bestaudio/bestvideo[height<={video_quality}]/best",
                    "format_sort": [f"ext:{extension}:mp4:mkv:mov"],
                    "writesubtitles": True,
                    "subtitleslangs": "all",
                }
            )
            ydl_opts["postprocessors"].append(
                {"key": "FFmpegVideoConvertor", "preferedformat": extension}
            )
            ydl_opts["postprocessors"].append(
                {"key": "FFmpegEmbedSubtitle", "already_have_subtitle": False},
            )

        # AUDIO
        elif extension in FORMAT_EXTS["audio"]:
            ydl_opts.update(
                {
                    "format": "bestaudio/best",
                    "format_sort": [f"ext:{extension}:m4a:mp3:ogg"],
                    "postprocessor_args": {
                        "thumbnailsconvertor+ffmpeg_o": [
                            "-c:v",
                            "png",
                            "-vf",
                            "crop=ih",
                        ]
                    },
                }
            )
            ydl_opts["postprocessors"].append(
                {
                    "key": "FFmpegExtractAudio",
                    "preferredcodec": extension,
                    "preferredquality": quality,
                    "nopostoverwrites": False,
                }
            )

        # ERROR
        else:
            raise ExtTypeError(
                "Failed to determine the extension type. Expected:",
                "VIDEO:",
                FORMAT_EXTS["video"],
                "AUDIO:",
                FORMAT_EXTS["audio"],
            )

        return ydl_opts

    def _prepare_filename(self, info: DataInfo) -> Path:
        with YoutubeDL(self.ydl_opts) as ydl:
            info_dict = info.info_dict
            info_dict["ext"] = self.ydl_opts["final_ext"]
            filename = ydl.prepare_filename(info_dict)
            return Path(filename)

    def _convert_info_dict(
        self, info_dict: InfoDict, force_process: bool = False
    ) -> ResultInfoList | PlaylistInfoList:
        """Convert raw InfoDict to DataInfo object

        Args:
            info_dict: Valid InfoDict to parse.
        """

        MISSING_TITLE = "NA"

        def get_thumbnail(info: InfoDict):
            return (
                info.get("thumbnail")
                or info.get("thumbnails")
                and info["thumbnails"][-1]["url"]
                or None
            )

        def convert_to_result(
            info: InfoDict, entries: list[DataInfo]
        ) -> ResultInfoList:
            return ResultInfoList(
                extractor=info["extractor_key"],
                id=info["id"],
                title=info.get("title", MISSING_TITLE),
                total_count=info.get("playlist_count") or len(entries),
                entries=entries,
            )

        if "entries" in info_dict:
            entries: list[DataInfo] = []

            for item in info_dict["entries"]:
                entries.append(
                    DataInfo(
                        url=item["url"],
                        thumbnail_url=get_thumbnail(item),
                        extractor=item["ie_key"],
                        id=item["id"],
                        title=item.get("title", MISSING_TITLE),
                        uploader=item.get("uploader", None),
                    )
                )

            if info_dict["title"] == info_dict["id"]:
                return convert_to_result(info_dict, entries)
            else:
                playlist = PlaylistInfoList(
                    url=info_dict["original_url"],
                    thumbnail_url=get_thumbnail(info_dict),
                    id=info_dict["id"],
                    extractor=info_dict["extractor_key"],
                    title=info_dict.get("title", MISSING_TITLE),
                    total_count=info_dict["playlist_count"],
                    entries=entries,
                )
                if force_process:
                    with cf.ThreadPoolExecutor(max_workers=5) as executor:
                        futures = []
                        try:
                            for thread in entries:
                                thread = executor.submit(thread.fetch_missed_data)
                                futures.append(thread)
                            cf.wait(futures)
                        except KeyboardInterrupt:
                            EVENT.set()
                            cf.wait(futures)
                return playlist
        else:
            data = DataInfo(
                url=info_dict["original_url"],
                thumbnail_url=get_thumbnail(info_dict),
                id=info_dict["id"],
                extractor=info_dict["extractor"],
                title=info_dict.get("title", MISSING_TITLE),
                uploader=info_dict.get("uploader", None),
                _info_dict=info_dict,
            )
            return convert_to_result(info_dict, [data])

    def _get_info_dict(self, query: str, limit: int | None = None) -> InfoDict | None:
        """Get InfoDict from supported yt-dlp URL.

        Raises:
            ValueError: The selected limit exceeds SEARCH_LIMIT.
        """

        ydl_opts = self.ydl_opts

        if limit:
            if limit < SEARCH_LIMIT:
                ydl_opts.update({"playlist_items": f"0:{limit}"})
            else:
                raise ValueError("Search limit is", SEARCH_LIMIT)

        with YoutubeDL(ydl_opts) as ydl:
            try:
                if info := ydl.extract_info(query, download=False):
                    if entries := info.get("entries"):
                        if not any(entries):
                            return None
                    print(info)
                    return InfoDict(info)
                else:
                    return None
            except DownloadError:
                raise

    def search_info(
        self, url: str, force_process: bool = False
    ) -> ResultInfoList | None:
        """Get one/multiple results from a valid URL.

        Args:
            url: URL to process.
            force_process: Fetch missing InfoDict(s) from Data entries.

        Returns:
            If extraction is succesful, return ResultInfoList object (Iterable with 'entries' field).
            Otherwise return None.
        """

        if info := self._get_info_dict(url):
            return self._convert_info_dict(info, force_process=force_process)
        else:
            return None

    def search_info_from_provider(
        self,
        query: str,
        provider: PROVIDER,
        limit: int = 5,
        force_process: bool = False,
    ) -> ResultInfoList | None:
        """Get a list of results from custom provider like YouTube or SoundCloud.

        Args:
            query: Query to search.
            provider: Provider where do the searchs.
            limit: Max of searchs to do.
            force_process: Fetch missing InfoDict(s) from Data entries.

        Returns:
            If extraction is succesful, return ResultInfoList object (Iterable with 'entries' field).
            Otherwise return None.
        """

        try:
            search = ValidProviders[provider].value
        except:
            raise ValueError(
                f"'{provider}' is not a valid provider. Available options:",
                *ValidProviders,
            )

        if info := self._get_info_dict(f"{search}{query}", limit=limit):
            return self._convert_info_dict(info, force_process=force_process)
        else:
            return None

    def download_multiple(
        self, query: Sequence[str | DataInfo | ResultInfoList]
    ) -> list[Path]:
        """Download a list of URLs/objects without checks.

        Args:
            query: URL or InfoType object to download.
        """

        items: list[DataInfo] = []
        final_downloads: list[Path] = []

        try:
            for data in query:
                match data:
                    case str():
                        if info := self.search_info(data):
                            items += info.entries
                        else:
                            raise DownloadError(f'Failed to fetch "{data}".')
                    case ResultInfoList():
                        items += data.entries
                    case DataInfo():
                        items.append(data)
                    case _:
                        raise ValueError()

            for item in items:
                filename = self.download_single(item, exist_ok=True)
                final_downloads.append(filename)

            return final_downloads
        except DownloadError:
            raise

    def download_single(
        self,
        data: DataInfo,
        exist_ok: bool = True,
        progress: list[Callable] | bool = True,
    ) -> Path:
        """Download from a single DataInfo object.

        Args:
            data: IEData to download.
            exist_ok: Ignore exception if file exist in output.
            progress: Callable which can get download information.

        Raises:
            DownloadError: yt-dlp throw an error.
            FileExistsError: If exist_ok is False, throw error when the file exist in output.
        """

        ydl_opts = self.ydl_opts

        if isinstance(progress, bool):
            ydl_opts.update({"noprogress": not progress})
        else:
            ydl_opts.update({"progress_hooks": progress, "noprogress": True})

        with YoutubeDL(params=ydl_opts) as ydl:
            temp = Path(self.temp_path / f"{data.extractor} {data.id}")
            temp.parent.mkdir(parents=True, exist_ok=True)

            try:
                filename = self._prepare_filename(data)

                if filename.is_file() and not exist_ok:
                    raise FileExistsError(filename.name)

                info = data.info_dict
                temp.write_text(json.dumps(info))
                ydl.download_with_info_file(temp)

                return filename
            finally:
                temp.unlink(missing_ok=True)
