from typing import cast, TypedDict
from pathlib import Path
import logging

from yt_dlp import YoutubeDL

from media_dl.types import Result
from media_dl.config import DIR_TEMP

fake_logger = logging.getLogger("YoutubeDL")
fake_logger.disabled = True


class FormatExtsDict(TypedDict):
    video: set[str]
    audio: set[str]
    storyboards: set[str]


FORMAT_EXTS = cast(FormatExtsDict, YoutubeDL._format_selection_exts)
_THUMBNAIL_EXTS = (
    "mp3",
    "mkv",
    "mka",
    "ogg",
    "opus",
    "flac",
    "m4a",
    "mp4",
    "mov",
)

QUALITY: dict[int, str] = {
    0: "144",
    1: "240",
    2: "360",
    3: "480",
    4: "720",
    5: "1080",
    6: "1440",
    7: "2160",
    8: "4320",
    9: "5250",
}
"""Dict to select video quality. For audio quality, use `QUALIY.keys()`."""


def gen_format_opts(extension: str, quality: int) -> dict:
    """Generate custom YDLOpts by provided arguments.

    Args:
        extension: Wanted file extension. Custom options will be generated by the extension type.
        quality: Wanted file quality. Range between [0-9].

    Raises:
        ValueError: `extension` or `quality` is invalid.
    """

    if not quality in QUALITY.keys():
        raise ValueError(
            "Invalid quality range. Expected int range [0-9].",
        )

    ydl_opts = {"final_ext": extension, "postprocessors": []}
    ydl_opts["postprocessors"].append(
        {"key": "FFmpegMetadata", "add_metadata": True, "add_chapters": True}
    )

    if extension in _THUMBNAIL_EXTS:
        ydl_opts["postprocessors"].append(
            {"key": "EmbedThumbnail", "already_have_thumbnail": False}
        )

    # VIDEO
    if extension in FORMAT_EXTS["video"]:
        video_quality = QUALITY[quality]

        ydl_opts.update(
            {
                "format": f"bestvideo[height<={video_quality}]+bestaudio/bestvideo[height<={video_quality}]/best",
                "format_sort": [f"ext:{extension}:mp4:mkv:mov"],
                "writesubtitles": True,
                "subtitleslangs": "all",
            }
        )
        ydl_opts["postprocessors"].append(
            {"key": "FFmpegVideoConvertor", "preferedformat": extension}
        )
        ydl_opts["postprocessors"].append(
            {"key": "FFmpegEmbedSubtitle", "already_have_subtitle": False},
        )

    # AUDIO
    elif extension in FORMAT_EXTS["audio"]:
        ydl_opts.update(
            {
                "format": "bestaudio/best",
                "format_sort": [f"ext:{extension}:m4a:mp3:ogg"],
                "postprocessor_args": {
                    "thumbnailsconvertor+ffmpeg_o": [
                        "-c:v",
                        "png",
                        "-vf",
                        "crop=ih",
                    ]
                },
            }
        )
        ydl_opts["postprocessors"].append(
            {
                "key": "FFmpegExtractAudio",
                "preferredcodec": extension,
                "preferredquality": quality,
                "nopostoverwrites": False,
            }
        )

    # ERROR
    else:
        raise ValueError(
            "Invalid extension type. Expected:",
            "VIDEO:",
            *FORMAT_EXTS["video"],
            "AUDIO:",
            *FORMAT_EXTS["audio"],
        )

    return ydl_opts


class YDLGeneric:
    """
    Arguments:
        extension (str): Prefered file extension type.
        quality (str, int): Prefered file quality. Must be compatible with `extension`.
            Range between [0-9] for audio; Resolution [144-5250] for video.
    """

    def __init__(self, extension: str = "m4a", quality: int = 9):
        opts = {
            "quiet": True,
            "no_warnings": True,
            "ignoreerrors": True,
            "extract_flat": True,
            "outtmpl": str(DIR_TEMP / "%(id)s.%(ext)s"),
            "logger": fake_logger,
        }
        formats = gen_format_opts(extension, quality)
        self.ydl = YoutubeDL(opts | formats)

    def download(self, url: str) -> Path:
        if data := self.ydl.extract_info(url, download=True):
            filename = self.ydl.prepare_filename(data)
            return Path(filename)
        else:
            return Path()

    def extract_url(self, url: str) -> list[Result]:
        """Extract URL information.

        Return:
            List of `Result`.
        """

        def get_thumbnail(info_dict: dict) -> str | None:
            return (
                info_dict.get("thumbnail")
                or info_dict.get("thumbnails")
                and info_dict["thumbnails"][-1]["url"]
                or None
            )

        item_list: list[Result] = []

        while True:
            if info := self.ydl.extract_info(url, download=False):
                info = cast(dict, info)

                if info["extractor"] == "generic":
                    break

                if entries := info.get("entries"):
                    entries = cast(list[dict], entries)

                    if not any(entries):
                        break

                    for item in entries:
                        item_list.append(
                            Result(
                                source="ydl-" + item["ie_key"],
                                id=item["id"],
                                title=item.get("title", None),
                                uploader=item.get("uploader", None),
                                duration=item.get("duration", None),
                                download=item["url"],
                                thumbnail=get_thumbnail(item),
                            )
                        )
                else:
                    item_list.append(
                        Result(
                            source="ydl-" + info["extractor_key"],
                            id=info["id"],
                            title=info.get("title", None),
                            uploader=info.get("uploader", None),
                            duration=info.get("duration", None),
                            download=info["original_url"],
                            thumbnail=get_thumbnail(info),
                        )
                    )
                break
            else:
                break
        return item_list
