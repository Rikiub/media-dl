from typing import cast
from enum import Enum

from yt_dlp.utils import MEDIA_EXTENSIONS


class FormatExt(Enum):
    video = cast(set[str], set(MEDIA_EXTENSIONS.common_video))
    audio = cast(set[str], set(MEDIA_EXTENSIONS.common_audio))
    thumbnail_compatible = {
        "mp3",
        "mkv",
        "mka",
        "ogg",
        "opus",
        "flac",
        "m4a",
        "mp4",
        "mov",
    }


QLT_TO_RES: dict[int, str] = {
    1: "144",
    2: "240",
    3: "360",
    4: "480",
    5: "720",
    6: "1080",
    7: "1440",
    8: "2160",
    9: "4320",
}
RES_TO_QLT: dict[str, int] = {value: key for key, value in QLT_TO_RES.items()}
QUALITY = cast(tuple[int], tuple(QLT_TO_RES.keys()))


def gen_format_opts(extension: str, quality: int) -> dict:
    """Generate custom YDLOpts by provided arguments.

    Args:
        extension: Wanted file extension. Custom options will be generated by the extension type.
        quality: Wanted file quality. Range between [1-9].

    Raises:
        ValueError: `extension` or `quality` is invalid.
    """

    if not quality in QUALITY:
        raise ValueError(
            "Invalid quality range. Expected int range [1-9].",
        )

    ydl_opts = {
        "final_ext": extension,
        "postprocessors": [
            {"key": "FFmpegMetadata", "add_metadata": True, "add_chapters": True},
        ],
    }

    if extension in FormatExt.thumbnail_compatible.value:
        ydl_opts["postprocessors"].append(
            {"key": "EmbedThumbnail", "already_have_thumbnail": False}
        )

    # VIDEO
    if extension in FormatExt.video.value:
        video_quality = QLT_TO_RES[quality]

        ydl_opts.update(
            {
                "format": f"bestvideo[height<={video_quality}]+bestaudio/bestvideo[height<={video_quality}]/best",
                "format_sort": [f"ext:{extension}:mp4:mkv:mov"],
                "writesubtitles": True,
                "subtitleslangs": "all",
            }
        )
        ydl_opts["postprocessors"] += [
            {"key": "FFmpegVideoConvertor", "preferedformat": extension},
            {"key": "FFmpegEmbedSubtitle", "already_have_subtitle": False},
        ]

    # AUDIO
    elif extension in FormatExt.audio.value:
        ydl_opts.update(
            {
                "format": "bestaudio/best",
                "format_sort": [f"ext:{extension}:m4a:mp3:ogg"],
                "postprocessor_args": {
                    "thumbnailsconvertor+ffmpeg_o": [
                        "-c:v",
                        "png",
                        "-vf",
                        "crop=ih",
                    ]
                },
            }
        )
        ydl_opts["postprocessors"].append(
            {
                "key": "FFmpegExtractAudio",
                "preferredcodec": extension,
                "preferredquality": quality,
                "nopostoverwrites": True,
            }
        )

    # ERROR
    else:
        raise ValueError(
            "Invalid extension type. Expected:\n"
            f"VIDEO: {', '.join(FormatExt.video.value)}\n"
            f"AUDIO: {', '.join(FormatExt.audio.value)}"
        )

    return ydl_opts
