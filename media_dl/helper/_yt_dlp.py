from typing import Sequence, cast, Callable, Any, NewType, TypedDict
from dataclasses import dataclass
import concurrent.futures as cf
from threading import Event
from pathlib import Path
import json

from yt_dlp import YoutubeDL
from yt_dlp.utils import DownloadError
from yt_dlp.extractor import gen_extractors


class ExtTypeError(Exception):
    """Handler to EXT type errors"""


class QualityTypeError(Exception):
    """Handler to quality"""


class FakeLogger:
    """Supress yt-dlp output"""

    @staticmethod
    def error(msg):
        pass

    @staticmethod
    def warning(msg):
        pass

    @staticmethod
    def debug(msg):
        pass


class FormatExtsDict(TypedDict):
    video: set[str]
    audio: set[str]
    storyboards: set[str]


FORMAT_EXTS = cast(FormatExtsDict, YoutubeDL._format_selection_exts)
_THUMBNAIL_EXTS = (
    "mp3",
    "mkv",
    "mka",
    "ogg",
    "opus",
    "flac",
    "m4a",
    "mp4",
    "mov",
)

_SEARCH_LIMIT = 50
PROVIDERS = {
    "soundcloud": f"scsearch{_SEARCH_LIMIT}:",
    "youtube": f"ytsearch{_SEARCH_LIMIT}:",
    "ytmusic": "https://music.youtube.com/search?q=",
    "bilibili": f"bilisearch{_SEARCH_LIMIT}:",
    "nicovideo": f"nicosearch{_SEARCH_LIMIT}:",
    "rokfin": f"rkfnsearch{_SEARCH_LIMIT}:",
    "yahoo": f"yvsearch{_SEARCH_LIMIT}:",
    "googlevideo": f"gvsearch{_SEARCH_LIMIT}:",
    "netverse": f"netsearch{_SEARCH_LIMIT}:",
    "prxstories": f"prxstories{_SEARCH_LIMIT}:",
    "prxseries": f"prxseries{_SEARCH_LIMIT}:",
}

QUALITY = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
_QUALITY_VIDEO = (
    "144",
    "240",
    "360",
    "480",
    "720",
    "1080",
    "1440",
    "2160",
    "4320",
    "5250",
)

EVENT = Event()

InfoDict = NewType("InfoDict", dict)


@dataclass
class IEType:
    title: str


@dataclass
class IEMeta:
    url: str
    id: str
    extractor: str
    thumbnail_url: str | None


@dataclass(slots=True)
class IEData(IEType, IEMeta):
    """yt-dlp InfoDict but simple."""

    creator: str | None
    _info_dict: InfoDict | None = None

    @property
    def info_dict(self) -> InfoDict:
        """
        Raises:
            DownloadError: Failed to fetch info data.
        """

        if self._create_info_dict(force_process=False) and self._info_dict:
            info_dict = cast(InfoDict, self._info_dict)
            return info_dict
        else:
            raise DownloadError("Failed to fetch info data.")

    def _create_info_dict(self, force_process=False) -> bool:
        """Fill missed data if not found InfoDict."""

        ydl = YDL(quiet=True)

        if self._info_dict and not force_process:
            return True
        else:
            if info_dict := not EVENT.set() and ydl._get_info_dict(self.url):
                self.creator = info_dict.get("uploader", self.creator)
                self.thumbnail_url = info_dict.get("thumbnail", self.thumbnail_url)
                self._info_dict = info_dict
                return True
            else:
                return False


@dataclass
class IESearch(IEType):
    total_count: int
    entries: list[IEData]


@dataclass(slots=True)
class IEPlaylist(IESearch, IEMeta):
    ...


class YDL:
    def __init__(
        self,
        quiet: bool = False,
        logger: Callable | None = None,
        tempdir: Path | None = None,
        outputdir: Path = Path.cwd(),
        ext: str = "mp4",
        ext_quality: int = 9,
    ):
        self.output_path = outputdir
        self.temp_path = tempdir or outputdir

        self.ydl_opts = {
            "paths": {
                "home": str(self.output_path),
                "temp": str(self.temp_path),
            },
            "quiet": quiet,
            "noprogress": quiet,
            "no_warnings": quiet,
            "ignoreerrors": False,
            "skip_download": False,
            "overwrites": False,
            "extract_flat": True,
            "retries": 3,
            "fragment_retries": 3,
            "outtmpl": "%(uploader)s - %(title)s.%(ext)s",
            "postprocessors": [],
        }
        self.ydl_opts = self._generate_ydl_opts(ext, ext_quality)

        if logger:
            self.ydl_opts.update({"logger": logger})
        elif quiet:
            self.ydl_opts.update({"logger": FakeLogger})

    @staticmethod
    def is_url_supported(url: str) -> bool:
        extractor = gen_extractors()
        for e in extractor:
            if e.suitable(url) and e.IE_NAME != "generic":
                return True
        return False

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def _generate_ydl_opts(
        self,
        extension: str,
        quality: int,
    ) -> dict[str, Any]:
        """Generate custom YDLOpts by provided arguments.

        Args:
            extension: Wanted file extension. Custom options will be generated by the extension type.
            quality: Wanted file quality. Range between [0-9].

        Raises:
            ExtTypeError: extension is not compatible.
            QualityTypeError: extension_quality is out of range.
        """

        if not quality in QUALITY:
            raise QualityTypeError(
                'Failed to determine "quality" range. Expected range between:',
                *QUALITY,
            )

        ydl_opts = self.ydl_opts
        ydl_opts.update({"final_ext": extension})
        ydl_opts["postprocessors"].append(
            {"key": "FFmpegMetadata", "add_metadata": True, "add_chapters": True}
        )

        if extension in _THUMBNAIL_EXTS:
            ydl_opts["postprocessors"].append(
                {"key": "EmbedThumbnail", "already_have_thumbnail": False}
            )

        # VIDEO
        if extension in FORMAT_EXTS["video"]:
            new_quality = _QUALITY_VIDEO[quality]

            ydl_opts.update(
                {
                    "format": f"bestvideo[height<={new_quality}]+bestaudio/bestvideo[height<={new_quality}]/best",
                    "format_sort": [f"ext:{extension}:mp4:mkv:mov"],
                    "writesubtitles": True,
                    "subtitleslangs": "all",
                }
            )
            ydl_opts["postprocessors"].append(
                {"key": "FFmpegVideoConvertor", "preferedformat": extension}
            )
            ydl_opts["postprocessors"].append(
                {"key": "FFmpegEmbedSubtitle", "already_have_subtitle": False},
            )

        # AUDIO
        elif extension in FORMAT_EXTS["audio"]:
            ydl_opts.update(
                {
                    "format": "bestaudio/best",
                    "format_sort": [f"ext:{extension}:m4a:mp3:ogg"],
                    "postprocessor_args": {
                        "thumbnailsconvertor+ffmpeg_o": [
                            "-c:v",
                            "png",
                            "-vf",
                            "crop=ih",
                        ]
                    },
                }
            )
            ydl_opts["postprocessors"].append(
                {
                    "key": "FFmpegExtractAudio",
                    "preferredcodec": extension,
                    "preferredquality": quality,
                    "nopostoverwrites": False,
                }
            )

        # ERROR
        else:
            raise ExtTypeError(
                'Failed to determine the "extension" type. Expected:',
                "VIDEO:",
                FORMAT_EXTS["video"],
                "AUDIO:",
                FORMAT_EXTS["audio"],
            )

        return ydl_opts

    def _prepare_filename(self, info: IEData) -> Path:
        ydl_opts = self.ydl_opts

        with YoutubeDL(ydl_opts) as ydl:
            info_dict = info.info_dict
            info_dict["ext"] = ydl_opts["final_ext"]
            filename = ydl.prepare_filename(info_dict)
            return Path(filename)

    def _convert_info_dict(
        self, info_dict: InfoDict, force_process: bool = False
    ) -> IEData | IEPlaylist:
        """Convert raw InfoDict to IEData object

        Args:
            info_dict: Valid InfoDict to parse.
        """

        def get_thumbnail(d: dict):
            return (
                d.get("thumbnail")
                or d.get("thumbnails")
                and d["thumbnails"][-1]["url"]
                or None
            )

        if "entries" in info_dict:
            data_list = []

            for item in info_dict["entries"]:
                if not item.get("title"):
                    continue

                data_list.append(
                    IEData(
                        url=item["url"],
                        extractor=item["ie_key"],
                        id=item["id"],
                        title=item["title"],
                        creator=item.get("uploader", None),
                        thumbnail_url=get_thumbnail(item),
                    )
                )

            if len(data_list) == 1:
                ie = data_list[0]
                ie._create_info_dict()
                return ie
            else:
                playlist = IEPlaylist(
                    url=info_dict["original_url"],
                    id=info_dict["id"],
                    extractor=info_dict["extractor_key"],
                    title=info_dict["title"],
                    total_count=info_dict["playlist_count"],
                    thumbnail_url=get_thumbnail(info_dict),
                    entries=data_list,
                )
                if force_process:
                    with cf.ThreadPoolExecutor(max_workers=5) as executor:
                        try:
                            futures = [
                                executor.submit(item._create_info_dict)
                                for item in data_list
                            ]
                            cf.wait(futures)
                        except KeyboardInterrupt:
                            EVENT.set()
                return playlist

        else:
            return IEData(
                url=info_dict["original_url"],
                id=info_dict["id"],
                extractor=info_dict["extractor"],
                title=info_dict["title"],
                creator=info_dict.get("uploader", None),
                thumbnail_url=get_thumbnail(info_dict),
                _info_dict=info_dict,
            )

    def _get_info_dict(self, query: str, limit: int | None = None) -> InfoDict | None:
        """Fetch InfoDict from valid URL"""

        ydl_opts = self.ydl_opts

        if limit:
            ydl_opts.update({"playlist_items": f"0:{limit}"})

        with YoutubeDL(ydl_opts) as ydl:
            try:
                if info := ydl.extract_info(query, download=False):
                    if "entries" in info and not any(info["entries"]):
                        return None
                    return InfoDict(info)
                else:
                    return None
            except DownloadError:
                raise

    def search_info(
        self, url: str, force_process: bool = False
    ) -> IESearch | IEPlaylist | None:
        """Simple search to get a InfoDict

        Args:
            url: URL to process.
            force_process: Fetch missing InfoDict(s) from Data entries.

        Returns:
            If the extraction is succesful, return a IEType object, otherwise return None.
        """

        if info := self._get_info_dict(url):
            info = self._convert_info_dict(info, force_process=force_process)

            if isinstance(info, IEData):
                return IESearch(title="NA", total_count=1, entries=[info])
            else:
                return info
        else:
            return None

    def search_info_from_provider(
        self, query: str, provider: str, limit: int = 5, force_process: bool = False
    ) -> IESearch | None:
        """Get one/multiple InfoDict from custom provider like YouTube or SoundCloud.

        Args:
            query: Query to process.
            provider: Provider where do the searchs.
            limit: Max of searchs to do.
            force_process: Fetch missing InfoDict(s) from Data entries.
        """

        try:
            provider = PROVIDERS[provider]
        except:
            raise ValueError(
                f"{provider} is not a valid provider. Available options:",
                PROVIDERS.keys(),
            )

        if info := self._get_info_dict(f"{provider}{query}", limit=limit):
            data = self._convert_info_dict(info, force_process=force_process)

            if isinstance(data, IEPlaylist):
                return IESearch(
                    title=query,
                    total_count=len(data.entries),
                    entries=data.entries,
                )
            else:
                return None
        else:
            return None

    def download_multiple(self, query: Sequence[str | IEType]) -> list[Path]:
        """Simple download without checks"""

        items: list[IEData] = []
        final_downloads: list[Path] = []

        try:
            for data in query:
                match data:
                    case str():
                        if info := self.search_info(data):
                            items += info.entries
                        else:
                            raise DownloadError(f'Failed to fetch "{data}".')
                    case IESearch() | IEPlaylist():
                        items += data.entries
                    case IEData():
                        items.append(data)
                    case _:
                        raise ValueError()

            for item in items:
                filename = self.download_single(item, exist_ok=True)
                final_downloads.append(filename)

            return final_downloads
        except DownloadError:
            raise

    def download_single(
        self,
        data: IEData,
        exist_ok: bool = True,
        progress: list[Callable] | bool = True,
    ) -> Path:
        """Download from a IEData object.

        Args:
            data: IEData to download.
            exist_ok: Ignore exception if file exist in output.
            progress: Callable which can get download information.

        Raises:
            DownloadError: yt-dlp throw an error.
            FileExistsError: If exist_ok is False, throw error when the file exist in output.
        """

        ydl_opts = self.ydl_opts

        if isinstance(progress, bool):
            ydl_opts.update({"noprogress": not progress})
        else:
            ydl_opts.update({"progress_hooks": progress, "noprogress": True})

        with YoutubeDL(params=ydl_opts) as ydl:
            temp = Path(self.temp_path / f"{data.extractor} {data.id}")
            temp.parent.mkdir(parents=True, exist_ok=True)

            try:
                filename = self._prepare_filename(data)

                if filename.is_file() and not exist_ok:
                    raise FileExistsError(filename.name)

                info = data.info_dict
                temp.write_text(json.dumps(info))
                ydl.download_with_info_file(temp)
                return filename
            finally:
                temp.unlink(missing_ok=True)
